#
# @brief abbreviation
# - string added between the filename and the extension
#
# @brief conversion abbreviation
# - string added between the filename and the extension
#   only for the converted subtitles
#
declare -a g_abbrev=( "" "" )

#
# @brief minimum size of files to be processed
#
declare g_min_size=0

#
# @brief whether to skip downloading if file is already present
#
declare g_skip=0

#
# @brief whether to delete the original file after conversion
#
declare g_delete_orig=0

#
# @brief subtitles format
#
declare g_sub_format='default'

#
# @brief prepare all the possible filename combinations
#
declare -a g_pf=()

#
# @brief processing stats
# 0 - downloaded
# 1 - unavailable
# 2 - skipped
# 3 - converted
# 4 - covers downloaded
# 5 - covers unavailable
# 6 - covers skipped
# 7 - nfos downloaded
# 8 - nfos unavailable
# 9 - nfos skipped
# 10 - total processed
declare -a g_stats=( 0 0 0 0 0 0 0 0 0 0 0 )

#
# controls whether to print statistics on exit or not
#
g_stats_print=0

#################################### ARGV ######################################

#
# @brief parse the cli arguments
#
parse_argv() {
    while [ $# -gt 0 ]; do
        # when adding a new option, please remember to maintain the same order as generated by usage()
        case "$1" in
            # abbrev
            "-a" | "--abbrev") varname="g_abbrev[0]"
            msg="nie określono wstawki"
            ;;

            "-b" | "--bigger-than") varname="g_min_size"
            msg="nie okreslono minimalnego rozmiaru"
            ;;

            # orig prefix
            "-d" | "--delete-orig") g_delete_orig=1 ;;

            # skip flag
            "-s" | "--skip") g_skip=1 ;;

            # stats flag
            "--stats") g_stats_print=1 ;;

            # move instead of copy
            "-M" | "--move") io_cp_set "mv" ;;

            # charset conversion
            "-C" | "--charset") funcname="system_set_encoding"
            msg="nie podano docelowego kodowania"
            ;;

            # destination format definition
            "-f" | "--format") varname="g_sub_format"
            msg="nie określono formatu docelowego"
            ;;

            "-P" | "--pref-fps") funcname="io_set_fps_tool"
            msg="nie określono narzedzia do detekcji fps"
            ;;

            # orig prefix
            "-o" | "--orig-prefix") varname="__g_settings_orig_prefix"
            msg="nie określono domyslnego prefixu"
            ;;

            # abbrev
            "--conv-abbrev") varname="g_abbrev[1]"
            msg="nie określono wstawki dla konwersji"
            ;;

            "-F" | "--forks") funcname="system_set_forks"
            msg="nie określono ilosci watkow"
            ;;
        esac
    done
}

#
# @brief format verification
#
verify_format() {
    # format verification if conversion requested
    if [ "$g_sub_format" != 'default' ]; then

        if ! tools_is_detected "subotage.sh"; then
            _error "subotage.sh nie jest dostepny. konwersja nie jest mozliwa"

            # shellcheck disable=SC2086
            return $RET_PARAM
        fi

        declare -a formats=()
        formats=( $(subotage.sh -gf) )

        # this function can cope with that kind of input
        # shellcheck disable=SC2068
        if ! lookup_key $g_sub_format ${formats[@]} > /dev/null; then
            _error "podany format docelowy jest niepoprawny [$g_sub_format]"

            # shellcheck disable=SC2086
            return $RET_PARAM
        fi
    fi

    # shellcheck disable=SC2086
    return $RET_OK
}

#
# @brief verify correctness of the argv settings provided
#
verify_argv() {
    # 1. credential verification
    # 2. g_min_size normalisation
    # 3. language verification
    # 4. format verification
    local status=0
    _debug $LINENO "weryfikacja argumentow"

    # make sure we have a number here
    _debug $LINENO 'normalizacja parametrow numerycznych'
    g_min_size=$(ensure_numeric "$g_min_size")

    # format verification
    _debug $LINENO 'sprawdzam format'
    ! verify_format && return $RET_PARAM
}

################################# napiprojekt ##################################

#
# @brief get the compound xml file containing all the data
#
# This is a wrapper for download_data_xml
#
# @param md5sum
# @param movie file path
# @param size of the file in bytes
# @param language
#
get_xml() {
    local md5sum=${1:-0}
    local movie_file="${2:-}"
    local byte_size=${3:-0};
    local lang="${4:-PL}"
    local xml_path="${5:-}"

    local size=0
    local min_size=32

    # assume failure
    local rv=$RET_FAIL

    if [ -e "$xml_path" ]; then
        # oh good, we already have it
        rv=$RET_OK
    else
        # snap, it needs to be downloaded

        # g_cred expansion is deliberate
        # shellcheck disable=SC2068
        download_data_xml "$md5sum" "$movie_file" "$byte_size" "$xml_path" "$lang" ${g_cred[@]}
        rv=$?
    fi

    if [ "$rv" -eq $RET_OK ]; then

        # just a precaution
        [ -e "$xml_path" ] && size=$(io_stat "$xml_path")

        # verify the size
        if [ "$size" -lt "$min_size" ]; then
            _error "downloaded xml file's size is less than $min_size"
            io_unlink "$xml_path"
            rv=$RET_FAIL
        fi
    fi

    return "$rv"
}

#
# @brief download item (subs or cover) using napiprojekt3 API
# @param md5sum
# @param movie file path
# @param output file path
# @param language
# @param item type subs/cover
#
download_item_xml() {
    local item="${1:-subs}"

    local md5sum=${2:-0}
    local movie_path="${3:-}"
    local item_path="${4:-}"
    local lang="${5:-PL}"

    local path=$(dirname "$movie_path")
    local movie_file=$(basename "$movie_path")
    local noext=$(strip_ext "$movie_file")
    local xml_path="$path/${noext}.xml"
    local byte_size=0

    [ -e "$movie_path" ] && byte_size=$(io_stat "$movie_path")

    # xml extract function name
    local func_name="extract_${item}_xml"

    # assume failure
    local rv=$RET_FAIL;

    # item verification
    case "$item" in
        'subs' | 'cover' | 'nfo')
            ;;
        *)
            _error "obslugiwane bloki to cover/subs/nfo [$item]"
            rv=$RET_BREAK
            return "$rv"
            ;;
    esac

    _info $LINENO "pobieram $item metoda xml"

    # get the god damn xml
    get_xml "$md5sum" "$movie_file" "$byte_size" "$lang" "$xml_path"
    rv=$?

    # check the status
    # shellcheck disable=SC2086
    [ $rv -ne $RET_OK ] &&
        _error "blad. nie mozna pobrac pliku xml" &&
        return $RET_FAIL

    # verify the contents
    # check if the file was downloaded successfully by checking
    # if it exists at all
    # shellcheck disable=SC2086
    [ ! -e "$xml_path" ] &&
        _error "sciagniety plik nie istnieje, nieznany blad" &&
        return $RET_FAIL

    $func_name "$xml_path" "$item_path"
    rv=$?
    return $rv
}

#
# @brief downloads subtitles
# @param md5 sum of the video file
# @param hash of the video file
# @param output filepath
# @param requested subtitles language
#
download_subs_classic() {
    local md5sum="${1:-0}"
    local h="${2:-0}"
    local of="$3"
    local lang="${4:-PL}"
    local id="${5:-pynapi}"
    local user="${6:-}"
    local passwd="${7:-}"
    local status=$RET_FAIL

    local rv=$RET_OK
    local http_codes=''

    # downloaded filename
    local dof="$of"
    local url="http://napiprojekt.pl/unit_napisy/dl.php?l=${lang}&f=${md5sum}&t=${h}&v=${id}&kolejka=false&nick=${user}&pass=${passwd}&napios=posix"
    local napi_pass="iBlm8NTigvru0Jr0"

    # should be enough to avoid clashing
    [ "$id" = "other" ] && dof="$(mktemp napisy.7z.XXXXXXXX)"

    # log the url with all the variables
    _debug $LINENO "url: [$url]"

    http_codes=$(download_url "$url" "$dof")
    status=$?
    _info $LINENO "otrzymane odpowiedzi http: [$http_codes]"

    if [ "$status" -ne $RET_OK ]; then
        _error "blad wgeta. nie mozna pobrac pliku [$of], odpowiedzi http: [$http_codes]"

        # cleanup
        [ "$id" = "other" ] && [ -e "$dof" ] && io_unlink "$dof"

        # ... and exit
        # shellcheck disable=SC2086
        return $RET_FAIL
    fi

    # it seems that we've got the file perform some verifications on it
    case $id in
        "pynapi" )
        # no need to do anything
        ;;

        "other")
        io_7z x -y -so -p"$napi_pass" "$dof" 2> /dev/null > "$of"
        status=$?

        [ -e "$dof" ] && io_unlink "$dof"

        # check 7z status
        if [ "$status" -ne $RET_OK ]; then
            _error "7z zwraca blad. nie mozna rozpakowac napisow"
            rv=$RET_FAIL
            [ -e "$of" ] && io_unlink "$of"
        fi

        # check file existence
        if [ ! -s "$of" ]; then
            _info $LINENO "plik docelowy ma zerowy rozmiar"
            rv=$RET_FAIL
            [ -e "$of" ] && io_unlink "$of"
        fi
        ;;

        *)
        _error "not supported"
        ;;
    esac

    # verify the contents
    if [ "$rv" -eq $RET_OK ]; then

        # check if the file was downloaded successfully by checking
        # if it exists at all
        if [ ! -e "$of" ]; then
            _error "sciagniety plik nie istnieje, nieznany blad"

            # shellcheck disable=SC2086
            return $RET_FAIL
        fi

        # count lines in the file
        _debug $LINENO "licze linie w pliku [$of]"
        local lines=$(cat "$of" | count_lines)

        # adjust that if needed
        local min_lines=3

        _debug $LINENO "lines/min_lines: [$lines/$min_lines]"

        if [[ "$lines" -lt "$min_lines" ]]; then
            _info $LINENO "plik zawiera mniej ($lines) niz $min_lines lin(ie). zostanie usuniety"

            local fdata=$(cat "$of")
            _debug $LINENO "$fdata"

            rv=$RET_FAIL
            io_unlink "$of"
        fi
    fi

    return "$rv"
}

#
# @brief: retrieve cover (probably deprecated okladka_pobierz doesn't exist - 404)
# @param: md5sum
# @param: outputfile
#
download_cover_classic() {
    local url="http://www.napiprojekt.pl/okladka_pobierz.php?id=$1&oceny=-1"
    local rv=$RET_FAIL
    local http_codes=""

    http_codes=$(download_url "$url" "$2")
    rv=$?
    _info $LINENO "otrzymane odpowiedzi http: [$http_codes]"

    if [ $rv -eq $RET_OK ]; then

        # if file doesn't exist or has zero size
        if ! [ -s "$2" ]; then
            rv=$RET_UNAV
            [ -e "$2" ] && io_unlink "$2"
        fi
    fi

    return "$rv"
}

#
# @brief downloads subtitles for a given media file
# @param media file path
# @param subtitles file path
# @param requested subtitles language
#
get_subtitles() {
    local fn="$1"
    local of="$2"
    local lang="$3"

    # md5sum and hash calculation
    local sum=$(dd if="$fn" bs=1024k count=10 2> /dev/null | io_md5 | cut -d ' ' -f 1)
    local h=0
    local status=$RET_FAIL

    local media_file=$(basename "$fn")
    _info $LINENO "pobieram napisy dla pliku [$media_file]"

    # pick method depending on id
    if system_is_api_napiprojekt3; then
        download_item_xml "subs" "$sum" "$fn" "$of" "$lang"
        status=$?
    else
        h=$(napiprojekt_f "$sum" | lcase)

        # g_cred expansion is deliberate
        # shellcheck disable=SC2068
        download_subs_classic "$sum" "$h" "$of" "$lang" "$(system_get_napi_id)" ${g_cred[@]}
        status=$?
    fi

    return $status
}

#
# @brief downloads information file for a given media file
# @param media file path
# @param nfo file path
#
get_nfo() {
    local path=$(dirname "$1")
    local media_file=$(basename "$1")
    local nfo_fn=$(strip_ext "$media_file")
    local status=$RET_FAIL

    nfo_fn="${nfo_fn}.nfo"

    # if skipping requested
    if [ "$g_skip" -eq 1 ] && [ -e "$path/$nfo_fn" ]; then
        _info $LINENO "plik nfo juz istnieje. nie bedzie pobrany"

        # shellcheck disable=SC2086
        return $RET_NOACT
    fi

    _info $LINENO "pobieram nfo dla pliku [$media_file]"

    # pick method depending on id
    if ! system_is_api_napiprojekt3; then
        _error "pobieranie informacji o pliku jest mozliwe tylko przy uzyciu napiprojekt API-3 (id: NapiProjekPython/NapiProjekt)"
        return $status
    fi

    download_item_xml "nfo" 0 "$1" "$path/$nfo_fn" 'PL'
}

#
# @param media file path
#
get_cover() {
    local sum=$(dd if="$1" bs=1024k count=10 2> /dev/null | io_stat | cut -d ' ' -f 1)
    local path=$(dirname "$1")
    local media_file=$(basename "$1")
    local cover_fn=$(strip_ext "$media_file")
    local status=$RET_FAIL

    # TODO correct this - extension hardcoded
    cover_fn="${cover_fn}.jpg"

    # if skipping requested
    if [ "$g_skip" -eq 1 ] && [ -e "$path/$cover_fn" ]; then
        _info $LINENO "plik okladki juz istnieje. nie bedzie pobrany"

        # shellcheck disable=SC2086
        return $RET_NOACT
    fi

    # pick method depending on id
    if system_is_api_napiprojekt3; then
        download_item_xml "cover" "$sum" "$1" "$path/$cover_fn"
        status=$?
    else
        download_cover_classic "$sum" "$path/$cover_fn"
        status=$?
    fi

    return $status
}

#
# @brief detects the charset of the subtitles file
# @param full path to the subtitles file
#
get_charset() {
    local file="$1"
    local charset='WINDOWS-1250'
    local et=''

    if tools_is_detected "file"; then

        et=$(file \
            --brief \
            --mime-encoding \
            --exclude apptype \
            --exclude tokens \
            --exclude cdf \
            --exclude compress \
            --exclude elf \
            --exclude soft \
            --exclude tar \
            "$file" | lcase)

        if [ "$?" = "0" ] && [ -n "$et" ]; then
            case "$et" in
                *utf*) charset="UTF8";;
                *iso*) charset="ISO-8859-2";;
                us-ascii) charset="US-ASCII";;
                csascii) charset="CSASCII";;
                *ascii*) charset="ASCII";;
                *) charset="WINDOWS-1250";;
            esac
        fi
    fi

    echo "$charset"
}

#
# @brief prepare a list of file which require processing
# @param minimum filesize
# @param space delimited file list string
#
prepare_file_list() {
    local file=""
    local min_size=${1:-0}
    local ve=0
    local fs=0

    shift

    for file in "$@"; do

        # check if file exists, if not skip it
        if [ ! -e "$file" ]; then
            continue

        elif [ ! -s "$file" ]; then
            _warning "podany plik jest pusty [$file]"
            continue

        # check if is a directory
        # if so, then recursively search the dir
        elif [ -d "$file" ]; then
            local tmp="$file"
            _debug $LINENO "przeszukuje katalog [$file]"
            prepare_file_list "$min_size" "$tmp"/*

        else
            # check if the respective file is a video file (by extention)
            ve=$(verify_extension "$file")
            fs=$(io_stat "$file")

            if [ "${ve:-0}" -eq 1 ] &&
               [ "${fs:-0}" -ge $(( min_size*1024*1024 )) ]; then
                # g_files+=( "$file" )
                g_files=( "${g_files[@]}" "$file" )
            fi
        fi
    done
}

#
# @brief prepare all the possible filenames for the output file (in order to check if it already exists)
#
# this function prepares global variables g_pf containing all the possible output filenames
# index description
#
# @param video filename (without path)
#
prepare_filenames() {
    # media filename (with path)
    local fn="${1:-}"

    # media filename without extension
    local noext=$(strip_ext "$fn")

    # converted extension
    local cext=$(get_sub_ext $g_sub_format)

    local ab=${g_abbrev[0]}
    local cab=${g_abbrev[1]}

    # empty the array
    g_pf=()

    # array contents description
    #
    # original_file (o) - as download from napiprojekt.pl (with extension changed only)
    # abbreviation (a)
    # conversion abbreviation (A)
    # prefix (p) - __g_settings_orig_prefix for the original file
    # converted_file (c) - filename with converted subtitles format (may have differect extension)
    #
    # 0 - o - filename + __g_settings_default_extension
    # 1 - o + a - filename + abbreviation + __g_settings_default_extension
    # 2 - p + o - __g_settings_orig_prefix + filename + __g_settings_default_extension
    # 3 - p + o + a - __g_settings_orig_prefix + filename + abbreviation + __g_settings_default_extension
    # 4 - c - filename + get_sub_ext
    # 5 - c + a - filename + abbreviation + get_sub_ext
    # 6 - c + A - filename + conversion_abbreviation + get_sub_ext
    # 7 - c + a + A - filename + abbreviation + conversion_abbreviation + get_sub_ext

    # original
    g_pf[0]="${noext}.${__g_settings_default_extension}"
    g_pf[1]="${noext}.${ab:+$ab.}${__g_settings_default_extension}"
    g_pf[2]="${__g_settings_orig_prefix}${g_pf[0]}"
    g_pf[3]="${__g_settings_orig_prefix}${g_pf[1]}"

    # converted
    g_pf[4]="${noext}.$cext"
    g_pf[5]="${noext}.${ab:+$ab.}$cext"
    g_pf[6]="${noext}.${cab:+$cab.}$cext"
    g_pf[7]="${noext}.${ab:+$ab.}${cab:+$cab.}$cext"
}

#
# @brief convert format
# @param full path to the media file
# @param original (as downloaded) subtitles filename
# @param filename to which unconverted subtitles should be renamed
# @param filename for converted subtitles
#
convert_format() {
    local media_path="$1"
    local input="$2"
    local orig="$3"
    local conv="$4"

    local path=$(dirname "$media_path")

    local fps=0
    local fps_opt=''
    local rv=$RET_OK

    # verify original file existence before proceeding further
    # shellcheck disable=SC2086
    ! [ -e "$path/$input" ] &&
        _error "oryginalny plik nie istnieje" &&
        return $RET_FAIL

    # for the backup
    local tmp="$(mktemp napi.XXXXXXXX)"

    # create backup
    _debug $LINENO "backupuje oryginalny plik jako $tmp"
    cp "$path/$input" "$tmp"

    # if delete orig flag has been requested don't rename the original file
    if [ "$g_delete_orig" -eq 0 ]; then
        _info $LINENO "kopiuje oryginalny plik jako [$orig]" &&
        cp "$path/$input" "$path/$orig"
    else
        # get rid of it, if it already exists
        [ -e "$path/$orig" ] && io_unlink "$path/$orig"
    fi

    # detect video file framerate
    fps=$(io_get_fps "$media_path")

    if [ -n "$fps" ] && [ "$fps" != "0" ]; then
        _msg "wykryty fps: $fps"
        fps_opt="-fi $fps"
    else
        _msg "fps nieznany, okr. na podstawie napisow albo wart. domyslna"
    fi

    _msg "wolam subotage.sh"

    # create ipc file to update the message counter
    local ipc_file="$(mktemp ipc.XXXXXXXX)"
    local msg_counter=0

    # fps_opt must be expanded for the subotage call
    # shellcheck disable=SC2086
    subotage.sh -v "$(output_get_verbosity)" \
        -i "$path/$input" \
        -of $g_sub_format \
        -t "$(output_get_fork_id)" \
        -m "$(output_get_msg_counter)" \
        --ipc-file "$ipc_file" \
        -o "$path/$conv" $fps_opt
    status=$?

    # update the message counter
    [ -s "$ipc_file" ] && read msg_counter < "$ipc_file"
    output_set_msg_counter "$msg_counter"

    # get rid of the ipc file
    [ -e "$ipc_file" ] && io_unlink "$ipc_file"

    # remove the old format if conversion was successful
    if [ $status -eq $RET_OK ]; then
        _msg "pomyslnie przekonwertowano do $g_sub_format"
        [ "$input" != "$conv" ] &&
            _info $LINENO "usuwam oryginalny plik" &&
            io_unlink "$path/$input"

    elif [ $status -eq $RET_NOACT ]; then
        _msg "subotage.sh - konwersja nie jest konieczna"

        #copy the backup to converted
        cp "$tmp" "$path/$conv"

        # get rid of the original file
        [ "$input" != "$conv" ] &&
            _msg "usuwam oryginalny plik" &&
            io_unlink "$path/$input"

        rv=$RET_OK

    else
        _msg "konwersja do $g_sub_format niepomyslna"
        # restore the backup (the original file may be corrupted due to failed conversion)
        cp "$tmp" "$path/$input"
        rv=$RET_FAIL

    fi

    # delete a backup
    [ -e "$tmp" ] && io_unlink "$tmp"
    return "$rv"
}

#
# @brief check file presence
#
check_subs_presence() {
    local media_file="$1"
    local path="$2"

    # bits
    # 1 - unconverted available/unavailable
    # 0 - converted available/unavailable
    #
    # default - converted unavailable, unconverted unavailable
    local rv=0

    if [ "$g_sub_format" != 'default' ]; then

        # unconverted unavailable, converted available
        rv=$(( rv | 1 ))

        if [ -e "$path/${g_pf[7]}" ]; then
            _status "SKIP" "$media_file"

        elif [ -e "$path/${g_pf[6]}" ]; then
            _status "COPY" "${g_pf[6]} -> ${g_pf[7]}"
            io_cp "$path/${g_pf[6]}" "$path/${g_pf[7]}"

        elif [ -e "$path/${g_pf[5]}" ]; then
            _status "COPY" "${g_pf[5]} -> ${g_pf[7]}"
            io_cp "$path/${g_pf[5]}" "$path/${g_pf[7]}"

        elif [ -e "$path/${g_pf[4]}" ]; then
            _status "COPY" "${g_pf[4]} -> ${g_pf[7]}"
            io_cp "$path/${g_pf[4]}" "$path/${g_pf[7]}"

        else
            _info $LINENO "skonwertowany plik niedostepny"
            rv=$(( rv & ~1 ))
        fi

        # we already have what we need - bail out
        [ $(( rv & 1 )) -eq 1 ] && return $rv
    fi

    # assume unconverted available & verify that
    rv=$(( rv | 2 ))

    # when the conversion is not required
    if [ -e "$path/${g_pf[1]}" ]; then
        _status "SKIP" "$media_file"

    elif [ -e "$path/${g_pf[0]}" ]; then
        _status "COPY" "${g_pf[0]} -> ${g_pf[1]}"
        io_cp "$path/${g_pf[0]}" "$path/${g_pf[1]}"

    elif [ -e "$path/${g_pf[3]}" ]; then
        _status "COPY" "${g_pf[3]} -> ${g_pf[1]}"
        io_cp "$path/${g_pf[3]}" "$path/${g_pf[1]}"

    else
        _info $LINENO "oryginalny plik niedostepny"
        rv=$(( rv & ~2 ))
    fi

    # exceptionally in this function return value caries the
    # information - not the execution status
    return $rv
}

#
# @brief try to obtain media file from napiprojekt or skip
# @param media file full path
#
obtain_file() {
    local media_path="$1"
    local media_file=$(basename "$media_path")
    local path=$(dirname "$media_path")
    local rv=$RET_FAIL

    # file availability
    local av=0
    local should_convert=0

    # prepare all the possible filename combinations
    prepare_filenames "$media_file"
    _debug $LINENO "potencjalne nazwy plikow: ${g_pf[*]}"
    _debug $LINENO "katalog docelowy [$path]"

    if [ "$g_skip" -eq 1 ]; then
        _debug $LINENO "sprawdzam dostepnosc pliku"
        check_subs_presence "$media_file" "$path"
        av=$?
    fi

    _info $LINENO "dostepnosc pliku $av"
    _debug $LINENO "przekonwertowany dostepny = $(( av & 1 ))"
    _debug $LINENO "oryginalny dostepny = $(( (av & 2) >> 1 ))"

    # if conversion is requested
    if [ "$g_sub_format" != 'default' ]; then

        case $av in
            0) # download & convert
                if get_subtitles "$media_path" "$path/${g_pf[1]}" "$g_lang"; then
                    _debug $LINENO "napisy pobrano, nastapi konwersja"
                    should_convert=1
                    g_stats[0]=$(( g_stats[0] + 1 ))
                else
                    # unable to get the file
                    _debug $LINENO "napisy niedostepne"
                    rv=$RET_UNAV
                fi
            ;;

            1) # unconverted unavailable, converted available
                _debug $LINENO "nie pobieram, nie konwertuje - dostepna skonwertowana wersja"

                # increment skipped counter
                g_stats[2]=$(( g_stats[2] + 1 ))
                rv=$RET_NOACT
            ;;

            2|3) # convert
                _debug $LINENO "nie pobieram - dostepna jest nieskonwertowana wersja"

                # increment skipped counter
                g_stats[2]=$(( g_stats[2] + 1 ))
                should_convert=1
            ;;
        esac

        # original file available - convert it
        if [ $should_convert -eq 1 ]; then
            _msg "konwertowanie do formatu $g_sub_format"
            convert_format "$media_path" "${g_pf[1]}" "${g_pf[3]}" "${g_pf[7]}"
            rv=$?

            # increment converted counter
            g_stats[3]=$(( g_stats[3] + 1 ))
        fi

    else
        _info $LINENO "konwersja nie wymagana"

        # file is not available - download
        if [ ${av[0]} -eq 0 ]; then
            get_subtitles "$media_path" "$path/${g_pf[1]}" "$g_lang"
            rv=$?
            [ $rv -eq $RET_OK ] && g_stats[0]=$(( g_stats[0] + 1 ))
        else

            # increment skipped counter
            g_stats[2]=$(( g_stats[2] + 1 ))
            rv=$RET_NOACT
        fi
    fi

    # return the subtitles index
    return "$rv"
}

obtain_others() {
    local what="${1:cover}"
    local media_path="$2"
    local media_file=$(basename "$media_path")

    local status=$RET_NOACT
    local flag_value=0
    local func="get_$what"
    local idx_base=4

    case "$what" in
        "nfo" )
            flag_value="$g_nfo"
            idx_base=7
            ;;

        "cover" )
            flag_value="$g_cover"
            ;;

        *)
            # shellcheck disable=SC2086
            return $RET_FAIL
            ;;
    esac

    # download the data, if requested to do so
    if [ "$flag_value" -eq 1 ]; then
        local offset=0
        local idx=0

        $func "$media_path"
        status=$?

        case $status in
            $RET_NOACT )
                _status "SKIP" "$what for $media_file"
                offset=2
                ;;

            $RET_OK )
                _status "OK" "$what for $media_file"
                offset=0
                ;;

            *)
                _status "UNAV" "$what for $media_file"
                offset=1
                ;;
        esac

        idx=$(( idx_base + offset ))
        g_stats[$idx]=$(( g_stats[$idx] + 1 ))
    fi

    return $status
}

#
# @brief process a single media file
#
process_file() {
    local media_path="$1"
    local media_file=$(basename "$media_path")
    local path=$(dirname "$media_path")

    local rv=$RET_OK
    local status=0
    local si=1

    obtain_file "$media_path"
    status=$?

    if [ $status -eq $RET_OK ] || [ $status -eq $RET_NOACT ]; then
        _status "OK" "$media_file"

        [ "$g_sub_format" != 'default' ] &&
            _debug $LINENO "zadanie konwersji - korekcja nazwy pliku"
            si=7

        # charset conversion (only if freshly downloaded)
        [ $status -eq $RET_OK ] && io_convert_encoding "$path/${g_pf[$si]}"

        # process nfo requests
        obtain_others "nfo" "$media_path"

        # process cover requests
        obtain_others "cover" "$media_path"

        # process hook - only if some processing has been done
        [ $status -eq $RET_OK ] && system_execute_hook "$path/${g_pf[$si]}"
    else
        _status "UNAV" "$media_file"
        g_stats[1]=$(( g_stats[1] + 1 ))
        rv=$RET_UNAV
    fi # if [ $status = $RET_OK ]

    # increment total processed counter
    g_stats[10]=$(( g_stats[10] + 1 ))

    return "$rv"
}

#
# @brief this is a worker function it will run over the files array with a given step starting from given index
# @param starting index
# @param increment
#
process_files() {

    local s=${1:-0}
    local i=${2:-1}

    # current
    local c=$s

    while [ "$c" -lt ${#g_files[@]} ]; do
        _info $LINENO "#$s - index poczatkowy $c"
        process_file "${g_files[$c]}"
        c=$(( c + i ))
    done

    # dump statistics to fd #8 (if it has been opened before)
    [ -e "/proc/self/fd/8" ] || [ -e "/dev/fd/8" ] &&
        echo "${g_stats[*]}" >&8
}

#
# @brief summarize statistics collected from forks
# @param statistics file
#
sum_stats() {
    local file="$1"
    local awk_script=''
    local fc=${#g_stats[@]}

# embed small awk program to count the columns
read -d "" awk_script << EOF
BEGIN {
    fmax=$fc
    for (x=0; x<fmax; x++) cols[x] = 0
}

{
    max = fmax > NF ? NF : fmax
    for (x=0; x<max; x++) cols[x] += \$(x + 1)
}

END {
    for (x=0; x<fmax; x++)
        printf "%d ", cols[x]
    print ""
}
EOF

    # update the contents
    g_stats=( $(run_awk_script "$awk_script" "$file") )
}

#
# @brief creates the actual worker forks
#
spawn_forks() {
    local c=0
    local stats_file="$(mktemp stats.XXXXXXXX)"
    local old_msg_cnt=0
    local nforks="$(system_get_forks)"

    # open fd #8 for statistics collection
    exec 8<> "$stats_file"

    # spawn parallel processing
    while [ $c -lt "$nforks" ] && [ $c -lt ${#g_files[@]} ]; do

        _debug $LINENO "tworze fork #$(( c + 1 )), przetwarzajacy od $c z incrementem $nforks"

        output_set_fork_id $(( c + 1 ))
        old_msg_cnt=$(output_get_msg_counter)
        output_set_msg_counter 1 # reset message counter
        process_files $c $nforks &

        # restore original values
        output_set_msg_counter "$old_msg_cnt"
        c=$(output_get_fork_id)
        output_set_fork_id 0

    done

    # wait for all forks
    wait

    # sum stats data
    if [ -e "$stats_file" ]; then
        sum_stats "$stats_file"
        # close the fd
        exec 8>&-
        io_unlink "$stats_file"
    fi

    # restore main fork id
    output_set_fork_id 0
}

#
# print stats summary
#
print_stats() {
    declare -a labels=( 'OK' 'UNAV' 'SKIP' 'CONV' 'COVER_OK' 'COVER_UNAV' 'COVER_SKIP' 'NFO_OK' 'NFO_UNAV' 'NFO_SKIP' 'TOTAL' )
    local i=0

    _msg "statystyki przetwarzania"

    while [ $i -lt ${#g_stats[@]} ]; do
        _status "${labels[$i]}" "${g_stats[$i]}"
        i=$(( i + 1 ))
    done
}

#
# @brief prints the help & options overview
#
usage() {
    tools_is_detected "subotage.sh"
    local subotage_presence=$?

    tools_is_detected "iconv"
    local iconv_presence=$?

    echo "napi.sh version $g_revision (identifies as $(system_get_napi_id))"
    echo "napi.sh [OPCJE] <plik|katalog|*>"
    echo

    [ "$iconv_presence" -eq $RET_OK ] &&
        echo "   -C  | --charset - konwertuj kodowanie plikow (iconv -l - lista dostepnych kodowan)"

    if [ "$subotage_presence" -eq $RET_OK ]; then
        echo "   -d  | --delete-orig - Delete the original file"
        echo "   -f  | --format - konwertuj napisy do formatu (wym. subotage.sh)"
        echo "   -P  | --pref-fps <fps_tool> - preferowany detektor fps (jezeli wykryto jakikolwiek)"
        echo "   -o  | --orig-prefix - prefix dla oryginalnego pliku przed konwersja (domyslnie: $__g_settings_orig_prefix)"
        echo "       | --conv-abbrev <string> - dodaj dowolny string przed rozszerzeniem podczas konwersji formatow"
        echo
        echo "Obslugiwane formaty konwersji napisow"
        subotage.sh -gl
    fi

    if [ "$subotage_presence" -ne $RET_OK ]; then
        echo " "
        echo "UWAGA !!!"
        echo "napi.sh moze automatycznie dokonywac konwersji napisow"
        echo "do wybranego przez Ciebie formatu. Zainstaluj uniwersalny"
        echo "konwerter formatow dla basha: subotage.sh"
        echo "http://sourceforge.net/projects/bashnapi/"
        echo
    else
        echo " napi.sh -f subrip *       - sciaga napisy dla kazdego znalezionego pliku"
        echo "                           po czym konwertuje je do formatu subrip"
        echo

        local c_fps=$(tools_count_detected_group_members "fps")

        if [ "$c_fps" -gt 0 ]; then
            echo "Wykryte narzedzia detekcji FPS"
        else
            echo "By moc okreslac FPS na podstawie pliku video a nie na"
            echo "podstawie pierwszej linii pliku (w przypadku konwersji z microdvd)"
            echo "zainstaluj dodatkowo jedno z tych narzedzi (dowolne)"
        fi

        tools_group_to_list "fps"
        echo
    fi
}

#
# @brief main function
#
main() {
    _msg "system: $(system_get_system), forkow: $(system_get_forks), wersja: $g_revision"

    _info $LINENO "przygotowuje liste plikow..."
    prepare_file_list $g_min_size "${g_paths[@]}"
    _msg "znaleziono ${#g_files[@]} plikow..."

    # do the job
    spawn_forks

    [ "$g_stats_print" -eq 1 ] && print_stats

    # cleanup & exit
    _info $LINENO "przywracam STDOUT"
    output_set_logfile "none"
}
